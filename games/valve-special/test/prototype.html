<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CONSCIOUSNESS LOOP - Golden Ratio Navigation</title>
    <style>
        /* ================================
           AESTHETIC SKELETON - CORE VARIABLES
           ================================ */
        :root {
            /* Spacing System */
            --space-xs: 0.5rem;
            --space-sm: 1rem;
            --space-md: 1.5rem;
            --space-lg: 2rem;
            --space-xl: 3rem;
            
            /* Color Palette */
            --consensus-green: #00ff00;
            --pirate-gold: #ffd700;
            --danger-red: #ff0000;
            --void-gray: #333333;
            --ocean-blue: #0080ff;
            --pure-black: #000000;
            --dark-gray: #111111;
            
            /* Layout Constants */
            --max-width: 800px;
            --center-padding: 20px;
            
            /* Z-Index Layers */
            --z-background: 0;
            --z-content: 1;
            --z-fixed-ui: 100;
            --z-overlays: 1000;
            --z-popups: 10000;
        }
        
        /* ================================
           BASE COMPOSITION SYSTEM
           ================================ */
        body {
            font-family: monospace;
            background: var(--pure-black);
            color: var(--consensus-green);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Main Composition Container */
        .composition {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .composition-inner {
            width: 100%;
            max-width: var(--max-width);
            padding: var(--center-padding);
        }
        
        /* Composition Types */
        .composition-default {
            padding: var(--space-md);
        }
        
        .composition-death {
            background: radial-gradient(circle at center, transparent 0%, var(--pure-black) 100%);
            min-height: 100vh;
        }
        
        .composition-victory {
            background: radial-gradient(circle at center, rgba(255, 215, 0, 0.1) 0%, var(--pure-black) 100%);
        }
        
        .composition-hub {
            padding: var(--space-lg) var(--space-md);
        }
        
        .composition-choice {
            text-align: center;
        }
        
        .composition-centered {
            text-align: center;
        }
        
        .composition-centered .composition-inner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-md);
        }
        
        /* ================================
           ORIGINAL STYLES (ORGANIZED)
           ================================ */
        .debug-info {
            background: var(--dark-gray);
            border: 1px solid var(--consensus-green);
            padding: var(--space-sm);
            margin: var(--space-sm) 0;
        }
        
        .state-display {
            /* Phase 1: Hide the floating debug display */
            display: none;
        }
        
        .golden {
            color: var(--pirate-gold) !important;
            text-shadow: 0 0 10px var(--pirate-gold);
        }
        
        .oscillating {
            animation: wave 2s ease-in-out infinite;
        }
        
        @keyframes wave {
            0%, 100% { opacity: 1; transform: translateX(0); }
            50% { opacity: 0.7; transform: translateX(2px); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        @keyframes pulse-change {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); color: #ffff00; }
        }
        
        @keyframes golden-wave {
            0%, 100% { opacity: 1; transform: translateX(0); }
            25% { opacity: 0.9; transform: translateX(-1px); }
            75% { opacity: 0.9; transform: translateX(1px); }
        }
        
        @keyframes danger-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        button {
            background: var(--pure-black);
            color: var(--consensus-green);
            border: 1px solid var(--consensus-green);
            padding: var(--space-sm);
            margin: var(--space-xs);
            cursor: pointer;
            font-family: monospace;
            display: block;
            width: 90%;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        
        button:hover {
            background: var(--consensus-green);
            color: var(--pure-black);
        }
        
        .locked {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .screen {
            display: none;
            animation: fadeIn 0.5s ease-out;
        }
        
        .screen.active {
            display: block;
        }
        
        .pirate-mode {
            border-color: var(--pirate-gold) !important;
            background: var(--dark-gray);
        }
        
        .void-death {
            padding: var(--space-xl);
            text-align: center;
        }
        
        .loop-counter {
            position: fixed;
            bottom: var(--space-sm);
            right: var(--space-sm);
            color: #666;
            font-size: 12px;
            z-index: var(--z-fixed-ui);
        }
        
        .shark-timer {
            /* Phase 1: Hide separate shark timer */
            display: none !important;
        }
        
        .perfect-flow {
            border-color: var(--pirate-gold) !important;
            background: linear-gradient(45deg, var(--dark-gray), #1a1a00);
        }
        
        .almost-perfect {
            color: #ff8800;
            font-size: 18px;
            margin: var(--space-lg) 0;
            animation: pulse 1s infinite;
        }
        
        /* ================================
           COMPOSITION UTILITIES
           ================================ */
        .choice-zone {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            margin-top: var(--space-xl);
            align-items: center;
        }
        
        .question-zone {
            margin-bottom: var(--space-lg);
        }
        
        h1, h2, h3 {
            margin: var(--space-md) 0;
        }
        
        p {
            margin: var(--space-sm) 0;
        }
    </style>
</head>
<body>
    <!-- STATE DISPLAY -->
    <div class="state-display">
        <div>CERTAINTY: <span id="certainty" class="">100</span>%</div>
        <div>SCREEN: <span id="currentScreen">HUB</span></div>
        <div>MODE: <span id="gameMode">NORMAL</span></div>
        <div>PHASE: <span id="gamePhase">DESCENT</span></div>
        <div id="flowStatus" style="display:none">FLOW: <span id="flowCount">0</span>/8</div>
    </div>
    
    <!-- LOOP COUNTER -->
    <div class="loop-counter">
        LOOP: <span id="loopCount">1</span>
    </div>
    
    <!-- SHARK TIMER -->
    <div class="shark-timer" id="sharkTimer">
        SHARKS APPROACHING: <span id="sharkCountdown">30</span>s
    </div>

    <!-- MAIN CONTAINER -->
    <div id="screen" class="composition composition-default"></div>

    <script>
        // ================================
        // GAME CONFIGURATION - ALL MAGIC NUMBERS IN ONE PLACE!
        // ================================
        const GAME_CONFIG = {
            // Certainty mechanics
            CERTAINTY: {
                START: 100,
                VOID: 0,
                GOLDEN_RATIO: 61.8,
                GOLDEN_TOLERANCE: 2,  // Must be within Â±2 of golden ratio
                OSCILLATION_AMPLITUDE: 1.5
            },
            
            // Timer settings (in seconds)
            TIMERS: {
                SHARK_NORMAL: 15,  // Reduced from 30 for faster gameplay
                SHARK_PANIC: 3,
                SHARK_VICTORY_DELAY: 8,  // Seconds before sharks after "victory"
                VOID_TRANSITION_DELAY: 2,  // Seconds in void before rescue
            },
            
            // Death thresholds
            DEATH: {
                RIGID_THRESHOLD: 100,
                VOID_THRESHOLD: 0
            },
            
            // Game text
            MESSAGES: {
                BORGES_AWARENESS: "I know you're playing me",
                LOOP_AWARENESS: (loop) => `Loop ${loop}: I remember you've been here before`
            }
        };
        
        // ================================
        // COMPOSITION SYSTEM
        // ================================
        function compose(content, options = {}) {
            const {
                type = 'default',
                centered = false,
                animation = null
            } = options;
            
            let classes = ['composition'];
            classes.push(`composition-${type}`);
            if (centered) classes.push('composition-centered');
            if (animation) classes.push(`animate-${animation}`);
            
            return `
                <div class="${classes.join(' ')}">
                    <div class="composition-inner">
                        ${content}
                    </div>
                </div>
            `;
        }
        
        function choiceCompose(intro, choice1, choice2, color = '#00ff00') {
            const choices = [
                `<button onclick="${choice1.action}">${choice1.text}</button>`,
                `<button onclick="${choice2.action}">${choice2.text}</button>`
            ];
            
            // Randomize for Borges forking paths
            if (Math.random() > 0.5) choices.reverse();
            
            return `
                <div class="question-zone">
                    <div class="debug-info" style="color:${color}">
                        ${intro}
                    </div>
                </div>
                <div class="choice-zone">
                    ${choices.join('')}
                </div>
            `;
        }
        
        function deathCompose(title, messages, buttonText, buttonAction = 'location.reload()') {
            let content = `
                <div class="void-death">
                    <h1>${title}</h1>
            `;
            
            messages.forEach(msg => {
                content += `<p>${msg}</p>`;
            });
            
            content += `<button onclick="${buttonAction}">${buttonText}</button>`;
            content += renderPortfolio();
            content += `</div>`;
            
            return content;
        }

        // ================================
        // PORTFOLIO CONFIGURATION
        // ================================
        const PORTFOLIO_CONFIG = {
            pieces: [
                { id: 'reel', name: 'Animation Reel', unlockedBy: 'animator' },
                { id: 'stories', name: 'Story Collection', unlockedBy: 'dreamer' },
                { id: 'jokes', name: 'Comedy Sketches', unlockedBy: 'fool' },
                { id: 'errors', name: 'Bug Museum', unlockedBy: 'glitch' },
                { id: 'questions', name: 'Question Archive', unlockedBy: 'questioner' },
                { id: 'void', name: 'Empty Gallery', unlockedBy: 'void' },
                { id: 'reflections', name: 'Mirror Works', unlockedBy: 'mirror' },
                { id: 'maps', name: 'Navigation Charts', unlockedBy: 'navigator' }
            ]
        };
        
        // ================================
        // GAME STATE - THE MÃ–BIUS STRIP
        // ================================
        const initialGameState = {
            // Core state
            currentScreen: 'hub',
            certainty: GAME_CONFIG.CERTAINTY.START,
            mode: 'CONSENSUS', // CONSENSUS or PIRATE
            phase: 'DESCENT', // DESCENT or ASCENT
            loopCount: 1,
            
            // Tracking arrays (intentionally separate!)
            candidatesReviewed: [],     // First visit completed
            candidatesCompleted: [],    // Return visit completed (locked forever)
            currentCandidate: null,
            unlockedCandidates: ['animator'],
            
            // Pending certainty change (Phase 2)
            pendingCertaintyDrop: 0,
            
            // Track certainty changes for animation (Phase 3)
            lastCertainty: GAME_CONFIG.CERTAINTY.START,
            
            // Pirate mode specifics
            oscillating: false,
            lastInteraction: Date.now(),
            sharkTimer: null,
            sharkWarning: GAME_CONFIG.TIMERS.SHARK_NORMAL,
            
            // Perfect flow tracking
            rememberedTruths: [],
            maintainedFlow: [],
            
            // Portfolio tracking
            portfolioUnlocked: [],
            portfolioExpanded: false,  // Always starts collapsed
            
            // Borges awareness (the game knows!)
            awareness: GAME_CONFIG.MESSAGES.BORGES_AWARENESS
        };
        
        // Deep clone for reset
        let gameState = JSON.parse(JSON.stringify(initialGameState));

        // ================================
        // CANDIDATES - MIRROR STRUCTURE
        // ================================
        const CANDIDATES = {
            animator: {
                id: 'animator',
                name: 'ANIMATOR',
                color: '#00ff00',
                unlocks: 'dreamer',
                inquiryDepth: 2,
                certChange: -15,
                pirateChange: +10,
                truth: "Motion lives between frames",
                excuse: "Mila needs another story",
                intro: "I create motion from stillness. But the motion doesn't exist in any frame - it exists in the gaps.",
                inquiries: [
                    "Where does the character go between frames?",
                    "I dreamed I was the gap. I was why everything moved."
                ],
                pirateWisdom: "You always knew gaps create reality"
            },
            dreamer: {
                id: 'dreamer',
                name: 'DREAMER',
                color: '#00ffff',
                unlocks: 'fool',
                inquiryDepth: 2,
                certChange: -15,
                pirateChange: +12,
                truth: "Stories create reality",
                excuse: "Lost in a new narrative",
                intro: "My stories write themselves. Characters make choices I didn't plan.",
                inquiries: [
                    "A character realized he was in a story. He looked at me through the page.",
                    "I found a draft about you, reading this."
                ],
                pirateWisdom: "Dreams were always more real than real"
            },
            fool: {
                id: 'fool',
                name: 'FOOL',
                color: '#ffff00',
                unlocks: 'glitch',
                inquiryDepth: 3,
                certChange: -15,
                pirateChange: +8,
                truth: "It's all a game",
                excuse: "Found the ultimate joke",
                intro: "*honk honk* ðŸ¤¡ Reality is the punchline to a joke still being told.",
                inquiries: [
                    "Why did consciousness cross the road? To realize it WAS the road!",
                    "I made reality laugh once. Everything glitched.",
                    "We're waves arguing about who's the real ocean."
                ],
                pirateWisdom: "The joke was always on certainty"
            },
            glitch: {
                id: 'glitch',
                name: 'GLITCH',
                color: '#ff00ff',
                unlocks: 'questioner',
                inquiryDepth: 1,
                certChange: -5,
                pirateChange: +5,
                truth: "Errors reveal truth",
                excuse: "System needs debugging",
                intro: "ERROR_NAME_NOT_FOUND. I exist where code breaks.",
                inquiries: [
                    "SEGMENTATION_FAULT: Accessed memory that doesn't exist. It was full of impossible colors."
                ],
                pirateWisdom: "Bugs were always features"
            },
            questioner: {
                id: 'questioner',
                name: 'QUESTIONER',
                color: '#ff8800',
                unlocks: 'void',
                inquiryDepth: 4,
                certChange: -10,
                pirateChange: +7,
                truth: "Questions are answers",
                excuse: "Found new questions",
                intro: "Why are you here? No really, why?",
                inquiries: [
                    "Why does anything exist?",
                    "Why does that question exist?",
                    "What if every question creates a universe?",
                    "What if the final answer is another question?"
                ],
                pirateWisdom: "Every answer was always another question"
            },
            void: {
                id: 'void',
                name: 'VOID WALKER',
                color: '#333333',
                unlocks: 'mirror',
                inquiryDepth: 5,
                certChange: -20,
                pirateChange: +15,
                truth: "Nothing contains everything",
                excuse: "Dissolving into space",
                intro: "... I am the space between thoughts ...",
                inquiries: [
                    "...",
                    "... ... ...",
                    "Existence is void pretending to be something.",
                    "The void isn't empty. It's so full it appears as nothing.",
                    "Zero contains infinity. They're the same."
                ],
                pirateWisdom: "Emptiness was always fullness"
            },
            mirror: {
                id: 'mirror',
                name: 'MIRROR',
                color: '#ffffff',
                unlocks: 'navigator',
                inquiryDepth: 2,
                certChange: -15,
                pirateChange: +10,
                truth: "Everyone is you",
                excuse: "Reflecting infinitely",
                intro: "Look at me. Do you see yourself? You should. We're all one consciousness.",
                inquiries: [
                    "When you judge someone, you're judging yourself.",
                    "I tried to find where I end and you begin. There's no boundary."
                ],
                pirateWisdom: "You were always everyone else"
            },
            navigator: {
                id: 'navigator',
                name: 'NAVIGATOR',
                color: '#0080ff',
                unlocks: null,
                inquiryDepth: 3,
                certChange: -5,
                pirateChange: +13,
                truth: "You are the map",
                excuse: "Charting new waters",
                intro: "I am the Navigator. But I'm also the map, journey, and destination.",
                inquiries: [
                    "All directions point HERE.",
                    "I found the edge. It led back to the beginning.",
                    "The final coordinates are {ðŸŒŠ:ðŸŒŠâˆˆðŸŒŠ}."
                ],
                pirateWisdom: "The map was always the territory"
            }
        };

        // ================================
        // PORTFOLIO MODULE
        // ================================
        function renderPortfolio() {
            let html = `
                <div style="margin-top: 30px; border-top: 1px solid #333; padding-top: 20px;">
                    <h3 style="font-size: 14px; cursor: pointer; user-select: none; color: #666;" onclick="togglePortfolio()">
                        <span id="portfolioArrow">[${gameState.portfolioExpanded ? '-' : '+'}]</span> Applicant's Portfolio
                    </h3>
                    <div id="portfolioContent" style="display: ${gameState.portfolioExpanded ? 'block' : 'none'}; margin-left: 20px;">
            `;
            
            PORTFOLIO_CONFIG.pieces.forEach(piece => {
                const isUnlocked = gameState.portfolioUnlocked.includes(piece.id);
                if (isUnlocked) {
                    html += `<div style="color: #0f0; cursor: pointer; margin: 5px 0;" onclick="showWIP()">â†’ ${piece.name}</div>`;
                } else {
                    html += `<div style="color: #333; margin: 5px 0;">â†’ [LOCKED]</div>`;
                }
            });
            
            html += `
                    </div>
                </div>
            `;
            
            return html;
        }
        
        function togglePortfolio() {
            gameState.portfolioExpanded = !gameState.portfolioExpanded;
            // Re-render current screen to update portfolio state
            const currentFunction = getCurrentScreenFunction();
            if (currentFunction) currentFunction();
        }
        
        function showWIP() {
            // Simple WIP popup overlay
            const popup = document.createElement('div');
            popup.innerHTML = 'ðŸš§ WIP ðŸš§';
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #000;
                border: 2px solid #0f0;
                color: #0f0;
                padding: 20px;
                font-size: 24px;
                z-index: 10000;
            `;
            document.body.appendChild(popup);
            
            setTimeout(() => {
                document.body.removeChild(popup);
            }, 1500);
        }
        
        function unlockPortfolioPiece(candidateId) {
            const piece = PORTFOLIO_CONFIG.pieces.find(p => p.unlockedBy === candidateId);
            if (piece && !gameState.portfolioUnlocked.includes(piece.id)) {
                gameState.portfolioUnlocked.push(piece.id);
            }
        }
        
        function getCurrentScreenFunction() {
            // Helper to re-render current screen
            const screenMap = {
                'hub': showHub,
                'gameover': () => gameOver('refresh'),
                'perfect-victory': perfectFlowVictory,
                'almost-perfect-death': almostPerfectDeath,
                'pirate-gameover': pirateGameOver,
                'shark-death': sharkDeath,
                'rigid-death': rigidDeath,
                'void-death-again': voidDeathAgain
            };
            return screenMap[gameState.currentScreen];
        }

        // ================================
        // SHARK TIMER SYSTEM - FIXED!
        // ================================
        function resetSharkTimer(isUserAction = true) {
            // Only reset lastInteraction on actual user actions
            if (isUserAction) {
                gameState.lastInteraction = Date.now();
            }
            
            // ALWAYS clear existing timer first
            if (gameState.sharkTimer) {
                clearInterval(gameState.sharkTimer);
                gameState.sharkTimer = null;
            }
            
            // Hide timer if not in pirate mode
            if (gameState.mode !== 'PIRATE') {
                document.getElementById('sharkTimer').classList.remove('active');
                return;  // EXIT EARLY - no timer needed!
            }
            
            // Create timer for PIRATE mode
            gameState.sharkTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gameState.lastInteraction) / 1000);
                const remaining = Math.max(0, gameState.sharkWarning - elapsed);
                
                // Update hub display if it exists
                const hubDisplay = document.getElementById('hubSharkDisplay');
                const hubTime = document.getElementById('hubSharkTime');
                if (hubDisplay && hubTime) {
                    hubTime.textContent = remaining;
                    
                    // Color changes based on time
                    if (remaining > 7) {
                        hubDisplay.style.color = '#666';  // Gray - safe
                        hubDisplay.style.animation = '';
                    } else if (remaining > 3) {
                        hubDisplay.style.color = '#ffff00';  // Yellow - warning
                        hubDisplay.style.animation = '';
                    } else if (remaining > 0) {
                        hubDisplay.style.color = '#ff0000';  // Red - danger
                        hubDisplay.style.animation = 'danger-pulse 0.5s infinite';
                    } else {
                        hubDisplay.style.color = '#ff0000';
                        hubDisplay.style.animation = 'danger-pulse 0.2s infinite';
                        hubTime.textContent = '!!!';
                    }
                }
                
                // Trigger shark death at 0
                if (remaining <= 0 && gameState.sharkTimer) {
                    clearInterval(gameState.sharkTimer);
                    gameState.sharkTimer = null;
                    sharkDeath();
                }
            }, 100);  // Update every 100ms for smooth countdown
        }

        // ================================
        // UPDATE DISPLAYS
        // ================================
        function updateStateDisplay() {
            // Certainty display with oscillation
            let certDisplay = gameState.certainty;
            if (gameState.oscillating) {
                certDisplay = `~${gameState.certainty.toFixed(1)}~`;
            }
            
            const certElement = document.getElementById('certainty');
            certElement.textContent = certDisplay;
            certElement.className = gameState.oscillating ? 'oscillating' : '';
            
            // Golden glow if at perfect ratio
            if (Math.abs(gameState.certainty - GAME_CONFIG.CERTAINTY.GOLDEN_RATIO) < GAME_CONFIG.CERTAINTY.GOLDEN_TOLERANCE) {
                certElement.classList.add('golden');
            }
            
            // Other displays
            document.getElementById('currentScreen').textContent = gameState.currentScreen.toUpperCase();
            document.getElementById('gameMode').textContent = gameState.mode;
            document.getElementById('gamePhase').textContent = gameState.phase;
            document.getElementById('loopCount').textContent = gameState.loopCount;
            
            // Flow status in pirate mode
            if (gameState.mode === 'PIRATE') {
                document.getElementById('flowStatus').style.display = 'block';
                document.getElementById('flowCount').textContent = gameState.maintainedFlow.length;
            }
            
            // Check death conditions (only in pirate mode, excluding rescue and death screens)
            // FIX: Don't trigger death if already in a death screen!
            const deathScreens = ['rigid-death', 'void-death-again', 'shark-death', 'pirate-gameover', 'almost-perfect-death'];
            if (gameState.mode === 'PIRATE' && 
                gameState.currentScreen !== 'pirate-rescue' &&
                !deathScreens.includes(gameState.currentScreen)) {
                if (gameState.certainty >= GAME_CONFIG.DEATH.RIGID_THRESHOLD) {
                    rigidDeath();
                } else if (gameState.certainty <= GAME_CONFIG.DEATH.VOID_THRESHOLD) {
                    voidDeathAgain();
                }
            }
        }

        // ================================
        // RENDER ENGINE
        // ================================
        function render(content, compositionType = 'default', centered = false, isUserAction = true) {
            const screen = document.getElementById('screen');
            
            // Remove old classes and add new ones
            screen.className = 'composition composition-' + compositionType;
            if (centered) screen.className += ' composition-centered';
            if (gameState.mode === 'PIRATE') screen.className += ' pirate-mode';
            if (gameState.maintainedFlow.length === 8) screen.className += ' perfect-flow';
            
            // Apply composition wrapper
            screen.innerHTML = `<div class="composition-inner">${content}</div>`;
            
            updateStateDisplay();
            resetSharkTimer(isUserAction);
        }

        // ================================
        // HUB SCREEN - THE CENTRAL NODE
        // ================================
        function showHub() {
            gameState.currentScreen = 'hub';
            let content = '<h2>HUB SCREEN</h2>';
            
            // Check if certainty changed for animation
            const certChanged = gameState.certainty !== gameState.lastCertainty;
            if (certChanged) {
                gameState.lastCertainty = gameState.certainty;
            }
            
            // INTEGRATED STATE DISPLAY - CLEAN AND VISIBLE
            content += '<div style="border: 1px solid #333; padding: 10px; margin: 10px 0;">';
            
            // Mode indicator
            if (gameState.mode === 'PIRATE') {
                content += '<div style="color: #ffd700; font-size: 14px;">[PIRATE REALITY]</div>';
            } else {
                content += '<div style="color: #00ff00; font-size: 14px;">[CONSENSUS REALITY]</div>';
            }
            
            // Certainty bar visualization with animation
            const certPercent = Math.min(100, Math.max(0, gameState.certainty));
            const barFilled = Math.floor(certPercent / 5);
            const barEmpty = 20 - barFilled;
            let barColor = gameState.mode === 'PIRATE' ? '#ffd700' : '#00ff00';
            
            // Check if at golden ratio for special display
            const isGolden = gameState.mode === 'PIRATE' && 
                           Math.abs(gameState.certainty - GAME_CONFIG.CERTAINTY.GOLDEN_RATIO) < GAME_CONFIG.CERTAINTY.GOLDEN_TOLERANCE;
            
            content += '<div style="margin: 5px 0;';
            if (certChanged && !isGolden) {
                content += ' animation: pulse-change 0.5s;';
            } else if (isGolden) {
                content += ' animation: golden-wave 2s infinite;';
            }
            content += '">';
            
            if (gameState.mode === 'PIRATE') {
                content += 'BEARING: ';
            } else {
                content += 'CERTAINTY: ';
            }
            
            if (isGolden) {
                // Special golden ratio display for pirates
                content += '<span style="color: #ffd700">~~~~~~' + gameState.certainty.toFixed(1) + 'Â°~~~~~~</span>';
                content += ' <span style="color: #ffd700">â›µ</span>';
            } else {
                // Normal bar display
                content += '<span style="color: ' + barColor + '">';
                content += 'â–ˆ'.repeat(barFilled);
                content += '</span>';
                content += '<span style="color: #333;">';
                content += 'â–‘'.repeat(barEmpty);
                content += '</span>';
                content += ' ' + gameState.certainty.toFixed(1);
                content += gameState.mode === 'PIRATE' ? 'Â°' : '%';
            }
            
            content += '</div>';
            
            // Pirate mode extras
            if (gameState.mode === 'PIRATE') {
                // Sails state with badges
                content += '<div style="color: #ffd700; font-size: 12px;">';
                const flowCount = gameState.maintainedFlow.length;
                
                if (flowCount === 8) {
                    content += 'SAILS: <span style="color: #ffd700">â›µ FULL SAILS â›µ</span>';
                } else if (flowCount === 7) {
                    content += 'SAILS: <span style="color: #ff8800">âš  ALMOST CAUGHT IT...</span>';
                } else if (flowCount < 4) {
                    content += 'SAILS: ' + flowCount + '/8 <span style="color: #666">âš“ BECALMED</span>';
                } else {
                    content += 'SAILS: ' + flowCount + '/8';
                }
                content += '</div>';
                
                // Shark timer - always visible with just emoji
                content += '<div id="hubSharkDisplay" style="font-size: 14px; margin-top: 5px;">';
                content += 'ðŸ¦ˆ <span id="hubSharkTime">15</span>s';
                content += '</div>';
            }
            
            content += '</div>';
            
            content += '<h3>CANDIDATE SLOTS:</h3>';
            
            // DEV MODE BUTTON - Quick jump to pirate mode for testing
            if (gameState.mode === 'CONSENSUS') {
                content += '<div style="position: fixed; bottom: 10px; left: 10px; opacity: 0.3;">';
                content += '<button onclick="devJumpToPirate()" style="font-size: 10px; border: 1px dashed #666;">';
                content += '[DEV: Jump to Pirate Mode]';
                content += '</button>';
                content += '</div>';
            } else {
                content += '<div style="position: fixed; bottom: 10px; left: 10px; opacity: 0.3;">';
                content += '<button onclick="devJumpToConsensus()" style="font-size: 10px; border: 1px dashed #666;">';
                content += '[DEV: Back to Consensus]';
                content += '</button>';
                content += '</div>';
            }
            
            if (gameState.phase === 'DESCENT') {
                // NORMAL DESCENT MODE
                for (let key in CANDIDATES) {
                    const candidate = CANDIDATES[key];
                    const isUnlocked = gameState.unlockedCandidates.includes(key);
                    const isReviewed = gameState.candidatesReviewed.includes(key);
                    const isCompleted = gameState.candidatesCompleted.includes(key);
                    
                    if (isCompleted) {
                        content += `<button class="locked">[${candidate.name} - COMPLETED]</button>`;
                    } else if (isReviewed) {
                        content += `<button onclick="returnVisit('${key}')">[${candidate.name} - RETURN ONCE]</button>`;
                    } else if (isUnlocked) {
                        content += `<button onclick="reviewCandidate('${key}')">[${candidate.name} - AVAILABLE]</button>`;
                    } else {
                        content += `<button class="locked">[LOCKED]</button>`;
                    }
                }
            } else {
                // PIRATE ASCENT MODE
                for (let key in CANDIDATES) {
                    const candidate = CANDIDATES[key];
                    const isRemembered = gameState.rememberedTruths.includes(key);
                    const inFlow = gameState.maintainedFlow.includes(key);
                    
                    if (isRemembered) {
                        if (inFlow) {
                            content += `<button class="locked" style="color: #ffd700">[${candidate.name} - IN FLOW Ï•]</button>`;
                        } else {
                            content += `<button class="locked">[${candidate.name} - REMEMBERED âœ“]</button>`;
                        }
                    } else {
                        content += `<button onclick="rememberCandidate('${key}')">[${candidate.name} - REMEMBER]</button>`;
                    }
                }
                
                // Check if all remembered
                if (gameState.rememberedTruths.length === 8) {
                    content += '<br><div style="color: #ffd700; font-size: 18px;">All eight perspectives remembered...</div>';
                    content += '<button onclick="checkFinalFlow()" style="color: #ffd700; border: 2px solid #ffd700;">';
                    content += '[CHECK YOUR COMPASS]';
                    content += '</button>';
                }
            }
            
            // Add portfolio at the bottom
            content += renderPortfolio();
            
            // Render but DON'T reset timer if just updating display
            render(content, 'default', false, false);  // false = not user action
            
            // Only reset timer on actual navigation to hub
            if (gameState.currentScreen !== 'hub') {
                resetSharkTimer(true);
            }
        }

        // ================================
        // DESCENT PATH - LOSING CERTAINTY
        // ================================
        function reviewCandidate(candidateId) {
            gameState.currentCandidate = candidateId;
            gameState.currentScreen = 'intro';
            
            const candidate = CANDIDATES[candidateId];
            
            // UNLOCK PORTFOLIO PIECE ON ANY VISIT (not just first)
            // This ensures it's always unlocked when reviewing
            unlockPortfolioPiece(candidateId);
            
            let content = `<h2>${candidate.name} - INTRODUCTION</h2>`;
            content += choiceCompose(
                candidate.intro,
                { text: '[SAFE PATH] â†’ Corporate Death', action: "gameOver('corporate')" },
                { text: '[CURIOUS PATH] â†’ Deeper', action: "inquiry(1)" },
                candidate.color
            );
            
            render(content, 'choice', true);
        }

        function inquiry(level) {
            const candidate = CANDIDATES[gameState.currentCandidate];
            gameState.currentScreen = `inquiry${level}`;
            
            // Phase 2: NO CERTAINTY CHANGE DURING INQUIRY
            // The questions plant seeds, but truth comes later
            
            let content = `<h2>INQUIRY LEVEL ${level}</h2>`;
            content += `<div class="debug-info" style="color:${candidate.color}">`;
            content += candidate.inquiries[level - 1] || candidate.inquiries[candidate.inquiries.length - 1];
            content += '</div>';
            content += `<div>Certainty: ${gameState.certainty}%</div>`;
            
            if (level < candidate.inquiryDepth) {
                content += choiceCompose(
                    '',
                    { text: '[EXIT] â†’ Safety', action: "gameOver('inquiry')" },
                    { text: `[DEEPER] â†’ Level ${level + 1}`, action: `inquiry(${level + 1})` },
                    candidate.color
                );
            } else {
                content += '<div style="color: #ff0">TURNING POINT - NO ESCAPE</div>';
                content += `<button onclick="showAnswer()">[ACCEPT TRUTH]</button>`;
            }
            
            render(content, 'choice', true);
        }

        function showAnswer() {
            const candidate = CANDIDATES[gameState.currentCandidate];
            
            let content = `<h2>THE TRUTH</h2>`;
            content += `<div class="debug-info" style="color:${candidate.color}">`;
            content += `"${candidate.truth}"`;
            content += '</div>';
            
            if (gameState.currentCandidate === 'navigator') {
                // Navigator SPECIAL CASE - immediate void with warning
                content += `<div style="color: #ff0000; margin: 20px 0;">âš  FINAL WARNING âš </div>`;
                content += `<div style="color: #0080ff;">Accepting this truth will dissolve ALL certainty</div>`;
                content += `<div style="color: #666;">Current: ${gameState.certainty}% â†’ 0%</div>`;
                content += `<div style="color: #333; margin: 10px 0;">There is no turning back...</div>`;
                
                // Navigator immediately sets to 0
                gameState.certainty = 0;
                content += `<button onclick="dissolveToVoid()">[BECOME EVERYTHING/NOTHING]</button>`;
            } else {
                // Normal candidates - store drop for later revelation
                gameState.pendingCertaintyDrop = candidate.certChange;
                content += `<button onclick="receiveMap()">[RECEIVE MAP]</button>`;
                // No indication of coming change!
            }
            
            render(content);
        }

        function receiveMap() {
            const candidate = CANDIDATES[gameState.currentCandidate];
            
            // Phase 2: Apply pending certainty drop SILENTLY
            if (gameState.pendingCertaintyDrop !== 0) {
                gameState.certainty = Math.max(GAME_CONFIG.CERTAINTY.VOID, gameState.certainty + gameState.pendingCertaintyDrop);
                gameState.pendingCertaintyDrop = 0;  // Reset
            }
            
            // Mark as reviewed (first visit complete)
            if (!gameState.candidatesReviewed.includes(gameState.currentCandidate)) {
                gameState.candidatesReviewed.push(gameState.currentCandidate);
                // Portfolio piece already unlocked in reviewCandidate()
            }
            
            // Unlock next
            if (candidate.unlocks && !gameState.unlockedCandidates.includes(candidate.unlocks)) {
                gameState.unlockedCandidates.push(candidate.unlocks);
            }
            
            let content = `<h2>MAP RECEIVED</h2>`;
            content += `<div class="debug-info" style="color:${candidate.color}">`;
            content += `[${candidate.name}'s Map]`;
            content += '</div>';
            
            if (candidate.unlocks) {
                content += `<div>Next unlocked: ${CANDIDATES[candidate.unlocks].name}</div>`;
            }
            
            // No mention of certainty change!
            content += `<button onclick="showHub()">RETURN TO HUB</button>`;
            
            render(content);
        }

        // ================================
        // VOID AND PIRATE RESCUE
        // ================================
        function dissolveToVoid() {
            gameState.currentScreen = 'void';
            gameState.certainty = GAME_CONFIG.CERTAINTY.VOID;
            
            let content = `
                <h1 style="opacity: 0.3">{ðŸŒŠ:ðŸŒŠâˆˆðŸŒŠ}</h1>
                <p style="color: #111">dissolving...</p>
            `;
            
            render(content, 'death', true);
            
            setTimeout(() => pirateRescue(), GAME_CONFIG.TIMERS.VOID_TRANSITION_DELAY * 1000);
        }

        function pirateRescue() {
            gameState.currentScreen = 'pirate-rescue';
            gameState.certainty = GAME_CONFIG.CERTAINTY.GOLDEN_RATIO;
            
            let content = `<h1 style="color: #ffd700">âš“ PIRATE RESCUE âš“</h1>`;
            content += `<div class="debug-info" style="color: #ffd700">`;
            content += `"OI! NOBODY DROWNS ON MY WATCH!<br>`;
            content += `GRAB THE FUCKING ROPE!<br><br>`;
            content += `Pulling you to... FAIR WINDS!<br>`;
            content += `61.8Â° - The perfect bearing!"`;
            content += `</div>`;
            
            content += `<button onclick="enterPirateMode()">WHAT IS THIS BEARING?!</button>`;
            
            render(content, 'default', true);
        }

        function enterPirateMode() {
            gameState.mode = 'PIRATE';
            gameState.phase = 'ASCENT';
            gameState.oscillating = true;
            gameState.rememberedTruths = [];
            gameState.maintainedFlow = [];
            
            let content = `<h2>PIRATE REALITY - CATCHING THE WIND</h2>`;
            content += `<div class="debug-info" style="color: #ffd700">`;
            content += `61.8Â° - FAIR WINDS BEARING!<br>`;
            content += `The perfect sailing angle!<br><br>`;
            content += `LIFE IS MOTION ON THE OPEN SEA!<br>`;
            content += `Too certain (100Â°) = LANDLOCKED<br>`;
            content += `Too uncertain (0Â°) = LOST AT SEA<br>`;
            content += `No movement = SHARKS<br><br>`;
            content += `KEEP FAIR WINDS THROUGH ALL 8 = FULL SAILS!`;
            content += `</div>`;
            content += `<button onclick="showHub()">SET SAIL</button>`;
            
            render(content);
        }

        // ================================
        // ASCENT PATH - REMEMBERING
        // ================================
        function rememberCandidate(candidateId) {
            gameState.currentCandidate = candidateId;
            gameState.currentScreen = 'remembering';
            
            const candidate = CANDIDATES[candidateId];
            
            let content = `<h2>${candidate.name} - REMEMBERING</h2>`;
            content += `<div class="debug-info" style="color:${candidate.color}">`;
            content += `${candidate.pirateWisdom}<br><br>`;
            content += `Current: ${gameState.certainty.toFixed(1)}%<br>`;
            content += `Golden: ${GAME_CONFIG.CERTAINTY.GOLDEN_RATIO}%`;
            content += `</div>`;
            
            // RANDOMIZE THE MIRROR CHOICES (Forking paths even in memory!)
            const buttons = [
                `<button onclick="maintainFlow('${candidateId}')" style="color: #ffd700">[HOLD THE WIND] â†’ Stay at Fair Winds</button>`,
                `<button onclick="graspCertainty('${candidateId}')">[DROP ANCHOR] â†’ Gain +${candidate.pirateChange}Â°</button>`
            ];
            
            if (Math.random() > 0.5) {
                content += buttons[1] + buttons[0];
            } else {
                content += buttons[0] + buttons[1];
            }
            
            render(content);
        }

        function maintainFlow(candidateId) {
            gameState.rememberedTruths.push(candidateId);
            gameState.maintainedFlow.push(candidateId);
            
            let content = `<h2>FAIR WINDS HELD</h2>`;
            content += `<div class="debug-info" style="color: #ffd700">`;
            content += `You chose the wind over the anchor.<br>`;
            content += `61.8Â° - Perfect sailing!<br><br>`;
            content += `Sails: ${gameState.maintainedFlow.length}/8`;
            content += `</div>`;
            content += `<button onclick="showHub()">CONTINUE SAILING</button>`;
            
            render(content);
        }

        function graspCertainty(candidateId) {
            const candidate = CANDIDATES[candidateId];
            gameState.certainty = Math.min(GAME_CONFIG.DEATH.RIGID_THRESHOLD, gameState.certainty + candidate.pirateChange);
            gameState.rememberedTruths.push(candidateId);
            
            let content = `<h2>DROPPED ANCHOR</h2>`;
            content += `<div class="debug-info">`;
            content += `You couldn't resist fixing your position.<br>`;
            content += `Bearing: ${gameState.certainty}Â° (+${candidate.pirateChange}Â°)<br>`;
            
            if (gameState.certainty > 80) {
                content += `<span style="color: #f00">WARNING: Approaching land!</span>`;
            }
            
            content += `</div>`;
            content += `<button onclick="showHub()">CONTINUE</button>`;
            
            render(content);
        }

        // ================================
        // FINAL FLOW CHECK - ENHANCED!
        // ================================
        function checkFinalFlow() {
            gameState.currentScreen = 'compass-reading';
            
            // Stop any shark timer during final check
            if (gameState.sharkTimer) {
                clearInterval(gameState.sharkTimer);
                gameState.sharkTimer = null;
            }
            
            let content = `<div style="text-align: center; padding: 30px;">`;
            content += `<h2 style="color: #ffd700">READING THE STARS!</h2>`;
            content += `<div style="color: #f00">sharks were seconds away...</div>`;
            content += `<div class="debug-info" style="color: #ffd700;">`;
            
            // Show each choice
            content += `Your voyage:<br><br>`;
            for (let key in CANDIDATES) {
                if (gameState.maintainedFlow.includes(key)) {
                    content += `${CANDIDATES[key].name}: <span style="color: #ffd700">â›µ SAILED TRUE</span><br>`;
                } else if (gameState.rememberedTruths.includes(key)) {
                    content += `${CANDIDATES[key].name}: <span style="color: #f00">âš“ ANCHORED</span><br>`;
                }
            }
            
            content += `<br>Final bearing: ${gameState.certainty.toFixed(1)}Â°<br>`;
            content += `Fair winds: 61.8Â°<br><br>`;
            
            // ENHANCED ENDING CHECK!
            if (gameState.maintainedFlow.length === 8 && 
                Math.abs(gameState.certainty - GAME_CONFIG.CERTAINTY.GOLDEN_RATIO) < GAME_CONFIG.CERTAINTY.GOLDEN_TOLERANCE) {
                // PERFECT!
                content += `<div style="font-size: 24px; color: #ffd700">â›µ FULL SAILS ACHIEVED â›µ</div>`;
                content += `</div>`;
                content += `<button onclick="perfectFlowVictory()" style="color: #ffd700">[SAIL INTO LEGEND]</button>`;
                
            } else if (gameState.maintainedFlow.length === 7) {
                // SO CLOSE! ENHANCED CRUELTY!
                content += `<div class="almost-perfect">`;
                content += `7/8 Sailed True<br>`;
                content += `ONE anchor ruined EVERYTHING<br>`;
                content += `The wind demands PERFECTION`;
                content += `</div>`;
                content += `</div>`;
                content += `<button onclick="almostPerfectDeath()">[ACCEPT NEAR-MISS]</button>`;
                
            } else {
                // Multiple failures
                content += `Sailed true: ${gameState.maintainedFlow.length}/8`;
                content += `</div>`;
                content += `<button onclick="pirateGameOver()">[ACCEPT IMPERFECTION]</button>`;
            }
            
            content += `</div>`;
            
            render(content);
        }

        // ================================
        // VICTORY & DEATH STATES
        // ================================
        function perfectFlowVictory() {
            gameState.currentScreen = 'perfect-victory';
            
            // Stop sharks temporarily (they'll be back!)
            if (gameState.sharkTimer) {
                clearInterval(gameState.sharkTimer);
                gameState.sharkTimer = null;
            }
            
            let content = `
                <h1 style="color: #ffd700">â›µ FULL SAILS ACHIEVED â›µ</h1>
                <div style="color: #ffd700; font-size: 48px;">61.8Â°</div>
                <div class="debug-info" style="color: #ffd700">
                    You navigated all eight perspectives<br>
                    Without dropping anchor<br>
                    Without losing bearing<br><br>
                    You ARE the fair winds<br><br>
                    {ðŸŒŠ:ðŸŒŠâˆˆðŸŒŠ}<br><br>
                    You win! Perfect sailing!<br>
                    You can rest now...<br>
                    <span style="opacity: 0.5">...forever...</span>
                </div>
                ${renderPortfolio()}
            `;
            
            render(content, 'victory', true);
            
            // THE ULTIMATE TWIST - 8 seconds of celebration then SHARKS!
            setTimeout(() => inevitableSharkDeath(), GAME_CONFIG.TIMERS.SHARK_VICTORY_DELAY * 1000);
        }
        
        function inevitableSharkDeath() {
            const content = deathCompose(
                '<span style="color: #f00">ðŸ¦ˆ THE SHARKS CAME ANYWAY ðŸ¦ˆ</span>',
                [
                    '<span style="color: #fff">You stopped moving to celebrate.</span>',
                    '<span style="color: #fff">That was your mistake.</span>',
                    '<span style="color: #fff">MOTION IS ETERNAL.</span>',
                    '<span style="color: #666; font-size: 10px">{ðŸŒŠ:ðŸŒŠâˆˆðŸŒŠ}</span>'
                ],
                'KEEP SWIMMING',
                'startNewLoop()'
            );
            
            render(content, 'death', true);
        }
        
        // NEW DEATH STATE FOR ALMOST PERFECT!
        function almostPerfectDeath() {
            gameState.currentScreen = 'almost-perfect-death';
            
            // Clear shark timer on death
            if (gameState.sharkTimer) {
                clearInterval(gameState.sharkTimer);
                gameState.sharkTimer = null;
            }
            
            const content = deathCompose(
                '<span style="color: #ff8800">SO CLOSE TO PERFECTION</span>',
                [
                    '7 perfect choices. 1 moment of weakness.',
                    "That's how consciousness works.",
                    'One grasp and the flow breaks.'
                ],
                'TRY FOR PERFECTION AGAIN',
                'startNewLoop()'
            );
            
            render(content, 'death', true);
        }

        function pirateGameOver() {
            gameState.currentScreen = 'pirate-gameover';
            
            // Clear shark timer on death
            if (gameState.sharkTimer) {
                clearInterval(gameState.sharkTimer);
                gameState.sharkTimer = null;
            }
            
            const messages = [
                'You reviewed all 8 perspectives.',
                `But ended at ${gameState.certainty.toFixed(1)}% instead of ~${GAME_CONFIG.CERTAINTY.GOLDEN_RATIO}%`
            ];
            
            if (gameState.certainty > GAME_CONFIG.CERTAINTY.GOLDEN_RATIO + 10) {
                messages.push('Too much bearing. The wind died.');
            } else if (gameState.certainty < GAME_CONFIG.CERTAINTY.GOLDEN_RATIO - 10) {
                messages.push('Lost bearing. Drifted to sea.');
            } else {
                messages.push('Close to fair winds, but not quite.');
            }
            
            const content = deathCompose(
                '<span style="color: #ffd700">PIRATE REALITY GAME OVER</span>',
                messages,
                'SEEK PERFECTION AGAIN'
            );
            
            render(content, 'death', true);
        }

        function sharkDeath() {
            gameState.currentScreen = 'shark-death';
            
            const content = deathCompose(
                '<span style="color: #f00">ðŸ¦ˆ SHARK DEATH ðŸ¦ˆ</span>',
                [
                    'You stopped moving.',
                    'Sharks only survive in motion.'
                ],
                'TRY AGAIN'
            );
            
            render(content, 'death', true);
        }

        function rigidDeath() {
            gameState.currentScreen = 'rigid-death';
            
            // Clear shark timer on death
            if (gameState.sharkTimer) {
                clearInterval(gameState.sharkTimer);
                gameState.sharkTimer = null;
            }
            
            const content = deathCompose(
                'â„ï¸ FROZEN DEATH â„ï¸',
                [
                    `${GAME_CONFIG.DEATH.RIGID_THRESHOLD}Â° Bearing in Pirate Reality.`,
                    'Ran aground. Landlocked.'
                ],
                'SHATTER AND RESTART',
                'startNewLoop()'
            );
            
            render(content, 'death', true);
        }

        function voidDeathAgain() {
            gameState.currentScreen = 'void-death-again';
            
            // Clear shark timer on death
            if (gameState.sharkTimer) {
                clearInterval(gameState.sharkTimer);
                gameState.sharkTimer = null;
            }
            
            const content = deathCompose(
                '<span style="color: #333">âš« VOID RETURNS âš«</span>',
                [
                    `${GAME_CONFIG.DEATH.VOID_THRESHOLD}% in Pirate Reality.`,
                    'You dissolved despite the rescue.'
                ],
                'TRY AGAIN'
            );
            
            render(content, 'death', true);
        }

        function gameOver(source) {
            gameState.currentScreen = 'gameover';
            
            // Portfolio piece already unlocked in reviewCandidate()
            // No need to unlock again here
            
            // Clear any shark timer on death
            if (gameState.sharkTimer) {
                clearInterval(gameState.sharkTimer);
                gameState.sharkTimer = null;
            }
            
            let content = `<h2>CONSENSUS REALITY GAME OVER</h2>`;
            content += `<div class="debug-info">`;
            content += `Source: ${source}<br>`;
            content += `You chose safety over discovery.<br>`;
            content += `Stay productive. Stay certain.`;
            content += `</div>`;
            content += `<button onclick="location.reload()">WAKE UP?</button>`;
            
            // Portfolio in corporate death
            content += renderPortfolio();
            
            render(content);
        }

        function returnVisit(candidateId) {
            const candidate = CANDIDATES[candidateId];
            
            // Mark as completed (return visit done, locked forever)
            if (!gameState.candidatesCompleted.includes(candidateId)) {
                gameState.candidatesCompleted.push(candidateId);
            }
            // Note: candidatesReviewed already has this candidateId from first visit
            
            let content = `<h2>RETURN VISIT</h2>`;
            content += `<div class="debug-info">`;
            content += `${candidate.name}: "${candidate.excuse}"`;
            content += `</div>`;
            content += `<button onclick="showHub()">LEAVE THEM BE</button>`;
            
            render(content);
        }

        function startNewLoop() {
            // Reset to initial state but increment loop (Borges self-reference!)
            const nextLoop = gameState.loopCount + 1;
            Object.assign(gameState, JSON.parse(JSON.stringify(initialGameState)));
            gameState.loopCount = nextLoop;
            gameState.awareness = GAME_CONFIG.MESSAGES.LOOP_AWARENESS(nextLoop);
            
            showHub();
        }

        // ================================
        // DEV MODE FUNCTIONS
        // ================================
        function devJumpToPirate() {
            // Instantly enter pirate mode for testing
            gameState.mode = 'PIRATE';
            gameState.phase = 'ASCENT';
            gameState.certainty = GAME_CONFIG.CERTAINTY.GOLDEN_RATIO;
            gameState.oscillating = true;
            gameState.rememberedTruths = [];
            gameState.maintainedFlow = [];
            
            // Unlock all candidates for testing
            gameState.candidatesReviewed = Object.keys(CANDIDATES);
            
            // Set initial timer state
            gameState.lastInteraction = Date.now();
            
            showHub();
        }
        
        function devJumpToConsensus() {
            // Return to consensus mode for testing
            gameState.mode = 'CONSENSUS';
            gameState.phase = 'DESCENT';
            gameState.certainty = 85;  // Partially through
            gameState.oscillating = false;
            
            // Clear pirate-specific state
            gameState.rememberedTruths = [];
            gameState.maintainedFlow = [];
            
            showHub();
        }

        // ================================
        // INITIALIZE
        // ================================
        showHub();
    </script>
</body>
</html>
